# Comment Project

## 用户登录——基于Session
为了保证线程安全。用户的信息需要线程安全。这需要用到ThreadLocal：当服务器收到用户发来的请求后，服务器会针对这个请求创建一个线程，
在拦截器(Interceptor)获得cookie之后，它可以用来找到对应的session， 服务器中存有若干session，session中匹配了合适的用户session
(通过用户发过来的Cookie，就是key是JSESSIONID的这个，比如JSESSIONID=19B2BCFF022976521321320D807253FB)。如果是首次访问，服务器
会给客户端发送一个cookie(key 是 JSESSIONID，value 是一串奇怪的东西)，并在服务器自身创建并储存一个session。session中存有该用户的信息(我们的
User实体类)，然后将它储存到ThreadLocal中即可保证线程安全。

ThreadLocal 创建的是线程的私有变量，每个线程都可以独立地改变自己的变量副本而不影响其他线程中的变量副本。一个线程可以创建多个不同的 ThreadLocal，
这些不同的 ThreadLocal 构成的键值对隶属于同一个 ThreadLocalMap。 
每个线程内部包含一个ThreadLocalMap变量，它是一个 HashMap，可以储存多个键值对，每个键值对是<ThreadLocal, Object>类型的键值对， 
键是 ThreadLocal 这个变量自身的引用(this/地址)，值就是不同 ThreadLocal 的值。
每个线程持有自己的 ThreadLocalMap 实例，这个映射表存储了该线程使用的所有 ThreadLocal 对象及其对应的值。
这种设计确保了不同线程的 ThreadLocal 变量互不干扰，实现了线程间的数据隔离。
提示：人类一般将 ThreadLocal 声明为 static，以实现同一个线程内的共享。

一个问题：为什么人类需要使用ThreadLocal，而不直接使用session获取用户信息？
有一种说法是：从线程中取用户信息会导致线程不安全
服务器（如Tomcat、Jetty等）会为每个进入的HTTP请求分配一个线程（从线程池中）来处理，也就是说：一个请求就是一个线程。

## 用户登录——基于Redis
那么这种通过session的办法会带来什么问题？
session共享问题：多台TOMCAT不共享session存储空间，请求切换到不同tomcat服务器会导致数据丢失
一些解决：session拷贝(浪费空间，拷贝延迟可能带来数据的不一致性)
session的替代方案应该满足：①数据共享；②内存存储；③key，value结构。所以需要用Redis

在保存验证码的过程中，替换为Redis后，如何设置key？
服务端只有一个 Redis ，而 session 是每个用户都有一个，如果我们将 key 储存为 "code"，那么有很多 user 的验证码都叫 code，
这会直接发生冲突，因此，每个用户的key需要是不同的。比如：手机号作为 key (tomcat会自动维护和创建session等)，value 就是验证码

随后，也需要保存用户到 Redis，用户对象需要 string --> json 序列化 // 另一个方案是 hash(map)，注意：
公司用的 string 是更多的。当然，hash 会更节省空间， string 会有括号、冒号、逗号等冗余。**本项目采用HASH**
此外，redis如何存储用户信息？答：随机生成一个 token 作为 key。value 再使用 hash 存储每个字段即可。
现在用户发送请求，需要带着 token，所以需要手动把 token 返回给前端(失去了JSSSIONID的自动匹配session)，使得客户端每次
请求应该都携带 token (这个携带 token 的功能由前端完成)

登录拦截器的优化：
如果用户访问的一直是无需登录(不经过拦截器)的页面或者路径，那么TOKEN不会被刷新，那么30分钟后，token会失效，这是不太合理的。
为此，需要一个解决方案：比如，再加一个拦截器，它专门用于刷新 token，保存用户，并放行所有请求；第二个拦截器再做拦截动作(第二个拦截器只做拦截)

```angular2html
Redis 登录流程总结：
①用户输入手机号，点击获取验证码，然后服务器生成验证码，将 手机号 + 验证码 存储在 Redis 中，2 min 内有效
②当用户输入验证码点击登录，(该过程不经过拦截器)，服务器获得验证码，与Redis中的验证码进行比对以验证其有效性，随后根据手机号查询用户信息(如果没有就注册)，
  然后将查询出的信息(脱敏，UserDTO)储存在 Redis 中，key 是 token，value 是UserDTO，30 min 有效
③随后访问需要登录的地方就经过拦截器(当然，更新后所有路径都经过第一个拦截器，它不负责拦截，但可以刷新token的有效期)，验证登录即可。如果访问了需要登录
  的路径，就把 UserDTO 存入 ThreadLocal 以实现线程安全。
```

## 商户缓存查询

**什么是缓存？** cache 临时存储数据的地方，一般读写性能较高

浏览器缓存：比如缓存静态资源。当浏览器缓存未命中，则去TOMCAT的Redis查询，如果redis未命中，则向数据库MySQL中查找
缓存的作用：①降低后端负载(减少读取MySQL的次数)；②提高读写效率，降低响应时间
缓存的成本：①数据的一致性成本；②一致性带来的代码维护成本；③运维成本

**添加Redis缓存**
添加缓存相当于添加中间层，优先从Redis中查找，如果Redis中没有就从数据库中查找。
当请求命中，不到数据库中。如果未命中，则需要双写，将数据返回给用户的同时，写入 redis

注意：list只能存储string，需要手动序列化，如果使用Gson，需要自己写@GsonIgnore注解，并实现响应接口以忽略这些字段

**缓存更新策略**
内存淘汰机制：
1. 内存淘汰：不用自己维护，利用redis的内存淘汰机制，当内存不足时淘汰部分数据，下次查询时更新缓存 
   缺陷：可能导致旧数据一直不被淘汰(数据库更新了该字段，但是redis及时命中，导致查到的永远是旧数据)
   一致性：差。维护成本：无。
2. 超时剔除：给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存。
   一致性：一般(比如30min expire，则数据库更新频率 > 30 min，可以保证一致性)；维护成本低
3. 主动更新：编写业务逻辑，在修改数据库同时，更新缓存；一致性：好。维护成本：高。

上述策略的使用取决于业务场景
1. 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存(可能加上超时)
2. 高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存

**主动更新策略：如何保证双写一致性？**
1. cache aside pattern 由缓存调用者，在更新数据库的同时更新缓存 [本项目采用]
2. write behind caching pattern 调用者只操作缓存，由其它线程异步将缓存数据持久化到数据库，保证最终一致
3. 将缓存与数据库整合为一个服务，由服务维护一致性

**cache aside pattern 的细节**
1. 删除缓存还是更新缓存？
   更新缓存：每次数据库更新都更新缓存(无论更新的字段是否再redis，都写入缓存)，如果写多查少，会导致无效写操作较多
   删除缓存：更新数据库时让缓存失效，查询时再更新缓存(重新写入缓存)[本项目采用]
2. 保证操作原子性：缓存与数据库操作同时成功或者失败
   单体系统：缓存与数据库放在一个事务
   分布式系统，TCC等分布式事务方案
3. 线程安全问题：先操作缓存还是先操作数据库？(视频38的分析)
   提示：先操作数据库，再删除缓存 方案出现问题的概率更低，即便出现问题，
   可以使用超时时间，万一写入旧数据，一段时间后也可以被清除
![img.png](img.png)

**缓存穿透**
客户端请求的数据在缓存和数据库中都不存在，这种情况下，此类请求永远会向数据库发送。缓存失效。
解决方案：
1. 缓存空对象，实现简单，维护方便；缺点：额外内存消耗(当然可以设置较短TTL)，造成短期不一致(比如id=4不存在，redis存入
   了一个null，而向数据库插入了id=4的记录，则在redis id=4的缓存到期之前，数据不一致；当然，这个问题可以通过 insert 时删一下 redis 即可)
2. 布隆过滤器，相当于在 客户端 --> redis --> MySQL 加了一层，客户端 --> 布隆过滤器 --> redis --> MySQL
   请求发过来后，先去布隆过滤器查询该记录是否存在，如果存在就放行，不存在就拒绝请求
   布隆过滤器的原理：bitmap，把数据库的数据经过一些哈希算法存到bitmap中，判断对应的位置是0 / 1
   布隆过滤器不存在是绝对的，布隆过滤器提示存在，数据却也可能不存在
   布隆过滤器优先：内存占用少，没有多余key；缺点：实现复杂，存在误判可能

解决缓存穿透：本项目使用缓存空对象。然后设置较短的TTL(没有插入数据库时删除缓存的操作)。
可能的优化：如果插入了一条记录，那么就删除空缓存。

**缓存雪崩**
同一时段大量缓存key同时失效或者Redis服务宕机(宕机才是最严重的)，导致大量请求到达数据库
解决方案
1. 给不同的key的TTL添加随机值(防止大量key同时失效)
2. 利用Redis集群提高服务可用性[哨兵模式：在集群模式下，监控Redis各个节点是否正常，如果主节点故障通过发布订阅模式通知其他节点，
   并进行故障转移，将其他正常的从节点指定为主节点。]
3. 给缓存业务加降级限流策略(比如快速拒绝服务，防止请求打入数据库)
4. 给业务添加多级缓存(L1 cache / L2 cache / L3 cache ... )

**缓存击穿**
也被称为热点key问题，一个被高并发访问并且缓存重建业务较复杂(比如多表查询)的key突然失效，无数的请求访问会在瞬间给数据库
带来巨大冲击。
解决方案：
1. 互斥锁(只需要一个线程创建，其它线程无需恢复缓存) 比如在重建缓存时，先获取互斥锁；重建完成，再释放锁。
   其它线程 a.redis未命中，b.获取互斥锁失败。 则其它线程可以先 sleep 一会，然后循环执行 a b 操作。但是等待会耗费很多性能，等待会降低性能。
2. 逻辑过期，向 redis 存储数据，不设置 TTL，则永不失效。比如可以在 value 字段加上 expire : 165613213(时间戳)，从逻辑维护
   是否过期。在活动(比如双11)的时候对热点key添加逻辑过期，活动结束移除这些key也是可以的。
   当某个请求(线程)发送查询，发现逻辑过期，获取互斥锁，然后开启新线程：①查询数据库，重建缓存数据；②写入缓存、重置逻辑、过期时间
   ③ 释放锁。原来的那个线程可以做一些其它的事情，比如：直接返回过期数据。
   其它线程呢？请求，发现逻辑过期，获取互斥锁失败，返回过期数据，结束，线程无需等待。

**解决缓存击穿：互斥锁实现**
redis 有一个 setnx lock 1 : set the value of a key, only if the key does not exist
比如：当第一个线程成功写入后，其它线程再尝试写入，则得到的结果一定是0，类似于互斥
提示：del lock (把 key = lock 的键值对释放，于是其它人就又可以)
为了防止 setnx 永远不释放，需要设置有效期。
为什么不能用Java的JUC自带的锁？答：因为分布式场景会失效，多个结点往往代表多个进程。
传统的锁都是为了解决单个JVM进程内的并发问题设计的，它们无法直接用于分布式场景中多个JVM进程之间的同步控制。

**解决缓存击穿：

**finally 的执行机制？**
在Java中，当try块内有return语句时，finally块的执行逻辑如下：
try块内的return语句首先计算其返回值，但是不会立即执行返回到方法调用者。
接下来，finally块会被执行。
如果finally块中没有改变返回值或没有包含它自己的return语句，那么原来由try块中的return语句计算出的返回值将被返回。
如果finally块中包含了return语句，那么finally块的返回值会覆盖try块的返回值，finally块的return语句的值会被返回。
总结来说，虽然return语句会先被计算，但finally块会在方法返回给调用者之前执行。这意味着，无论try块的执行路径如何，finally块总是会执行，并且它的执行可以影响方法的最终返回结果，特别是当finally块中包含return语句时。这是一种确保资源被清理的强大机制，但也需要小心使用，以避免意外覆盖返回值


